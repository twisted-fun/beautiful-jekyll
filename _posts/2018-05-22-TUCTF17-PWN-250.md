---
layout: post
title: TUCTF17 PWN 250
tags: [ctf, pwn, write-up, tuctf17]
---

### Challenge: [guestbook](../ctfs/tuctf17/pwn/guestbook/guestbook)
(**PS**: *libc was provided for this challenge*)

### Reversing
Let's start with basic analysis of given binary
```bash
$ file ./guestbook
guestbook: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=bc73592d4897267cd1097b0541dc571d051a7ca0, not stripped
$ checksec ./guestbook
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```
So we have PIE and NX enabled, which in most scenarios require combination of information leak and ROP (Return Oriented Programming). I quickly fire up IDA for further analysis.
```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [sp+0h] [bp-98h]@16
  int v5; // [sp+64h] [bp-34h]@11
  int v6; // [sp+68h] [bp-30h]@7
  char *dest[4]; // [sp+6Ch] [bp-2Ch]@2
  char v8; // [sp+7Fh] [bp-19h]@5
  int (**v9)(const char *); // [sp+80h] [bp-18h]@4
  char **v10; // [sp+84h] [bp-14h]@4
  char *v11; // [sp+88h] [bp-10h]@2
  char v12; // [sp+8Fh] [bp-9h]@4
  int i; // [sp+90h] [bp-8h]@1

  setvbuf(stdout, 0, 2, 0x14u);
  puts("Please setup your guest book:");
  for ( i = 0; i <= 3; ++i )
  {
    printf("Name for guest: #%d\n>>>", i);
    v11 = (char *)malloc(0xFu);
    __isoc99_scanf("%15s", v11);
    v11[14] = 0;
    dest[i] = v11;
  }
  v10 = dest;
  v9 = &system;
  v12 = 1;
  while ( v12 )
  {
    do
      v8 = getchar();
    while ( v8 != 10 && v8 != -1 );
    puts("---------------------------");
    puts("1: View name");
    puts("2: Change name");
    puts("3. Quit");
    printf(">>");
    v6 = 0;
    __isoc99_scanf("%d", &v6);
    switch ( v6 )
    {
      case 2:
        printf("Which entry do you want to change?\n>>>");
        v5 = -1;
        __isoc99_scanf("%d", &v5);
        if ( v5 >= 0 )
        {
          printf("Enter the name of the new guest.\n>>>");
          do
            v8 = getchar();
          while ( v8 != 10 && v8 != -1 );
          gets(&s);
          strcpy(dest[v5], &s);
        }
        else
        {
          puts("Enter a valid number");
        }
        break;
      case 3:
        v12 = 0;
        break;
      case 1:
        readName((int)dest);
        break;
      default:
        puts("Not a valid option. Try again");
        break;
    }
  }
  return 0;
}

int __cdecl readName(int a1)
{
  int result; // eax@2
  int v2; // [sp+0h] [bp-8h]@1

  printf("Which entry do you want to view?\n>>>");
  v2 = -1;
  __isoc99_scanf("%d", &v2);
  if ( v2 >= 0 )
    result = puts(*(const char **)(4 * v2 + a1));
  else
    result = puts("Enter a valid number");
  return result;
}
```