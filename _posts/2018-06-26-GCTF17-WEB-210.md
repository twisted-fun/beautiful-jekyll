---
layout: post
title: Google CTF 2018 WEB 210
tags: [ctf, web, write-up, gctf18, css-injection, cookie-injection]
---

### Challenge: Cat Chat

### Description
You discover this cat enthusiast chat app, but the annoying thing about it is that you're always banned when you start talking about dogs. Maybe if you would somehow get to know the admin's password, you could fix that.  

[https://cat-chat.web.ctfcompetition.com/](https://cat-chat.web.ctfcompetition.com/)  

### First look
When opening the challenge URL, we are quickly make a few observations
- Its a chat application
- We are assigned a random nickname
- Redirected URL is having a unique chat room id
- Rules section stats that `Dog talk` can get you banned
- `/name new_nick` can be used to change your nickname
- `/report` can be used to inform admin about users doing `Dog talk` and get them banned
- Lastly we also have source code for `server.js` provided  


![first look](../ctfs/gctf18/web/cat_chat-210/first_look.png)

### Goal Assumptions
From the challenge description we can make out that we need to get access of admin's password/session. Looking at the application, we can make our first guess that we have to perform client side attack like XSS in order to get session of admin user.
So with this goal in mind lets start the assessment of the application.

### Bug hunting in code
Let's look at the page source. We can see there is a comment describing additional `Admin commands` for chat room.  
**Admin commands**:
- `/secret asdfg` - Sets the admin password (*that we have to steal*) to be sent to the server with each command for authentication. It's enough to set it once a year, so no need to issue a /secret command every time you open a chat room.
- `/ban UserName` - Bans the user with UserName from the chat (requires the correct admin password to be set) (*meaning we cannot directly ban someone, -_-*)  

We also have access to `server.js`, from there we can see how these commands are handled.  
I will break down important parts of the source code in order to explain better :)

**Some libraries imported**
```
const http = require('http');
const express = require('express');
const cookieParser = require('cookie-parser')
const uuidv4 = require('uuid/v4');
const SSEClient = require('sse').Client;
const admin = require('./admin');
const pubsub = require('@google-cloud/pubsub')();
```
Oh admin.js *hmm* but we don't have access to it.

**Some initializations**
```
const app = express();
app.set('etag', false);
app.use(cookieParser());
```
Nothing interesting..

**Oh Authorization Check** *interesting*
```
// Check if user is admin based on the 'flag' cookie, and set the 'admin' flag on the request object
app.use(admin.middleware);
```
As we don't have access to `admin.js` the comment helps us understand that when admin sends a request to server it will contain a `flag` cookie whose value will be checked by `admin.middleware`. If the `flag` value is correct `admin` flag will be set on the request object to be used later in the code.

**banned status check**
```
// Check if banned
app.use(function(req, res, next) {
  if (req.cookies.banned) {
    res.sendStatus(403);
    res.end();
  } else {
    next();
  }
});
```
So if a set `banned` cookie is found in our browser session we will get a `403` status.

**Commands handling** *part we were waiting for*
```
// Process incoming messages
app.all(roomPath + '/send', async function(req, res) {
  let room = req.params.room, {msg, name} = req.query, response = {}, arg;
  console.log(`${room} <-- (${name}):`, msg)
  if (!(req.headers.referer || '').replace(/^https?:\/\//, '').startsWith(req.headers.host)) {
    response = {type: "error", error: 'CSRF protection error'};
  } else if (msg[0] != '/') {
    broadcast(room, {type: 'msg', name, msg});
  } else {
    switch (msg.match(/^\/[^ ]*/)[0]) {
      case '/name':
        if (!(arg = msg.match(/\/name (.+)/))) break;
        response = {type: 'rename', name: arg[1]};
        broadcast(room, {type: 'name', name: arg[1], old: name});
      case '/ban':
        if (!(arg = msg.match(/\/ban (.+)/))) break;
        if (!req.admin) break;
        broadcast(room, {type: 'ban', name: arg[1]});
      case '/secret':
        if (!(arg = msg.match(/\/secret (.+)/))) break;
        res.setHeader('Set-Cookie', 'flag=' + arg[1] + '; Path=/; Max-Age=31536000');
        response = {type: 'secret'};
      case '/report':
        if (!(arg = msg.match(/\/report (.+)/))) break;
        var ip = req.headers['x-forwarded-for'];
        ip = ip ? ip.split(',')[0] : req.connection.remoteAddress;
        response = await admin.report(arg[1], ip, `https://${req.headers.host}/room/${room}/`);
    }
  }
  console.log(`${room} --> (${name}):`, response)
  res.json(response);
  res.status(200);
  res.end();
});
```
Here is the breakdown of the code
- All requests hitting `/send` are handled by this
- Has a CSRF check that if `Referer` header is not same as request `host` then throw a CSRF protection error
- If `msg` does not have any command broadcast the message in the chat room
- `/name` broadcast the name changing instruction to the room (*hmm ok*)
- `/ban` checks for `req.admin` flag (*set in above code if right flag cookie is found in request*) and broadcast user banning instruction to the room (*hmm ok*)
- `/secret` (*Whoa!*) if you see carefully here, you will notice there is a **cookie injection**. Not sure how we can use this bug to get admin `flag` cookie but we will keep it in mind. (*nice!*)
- `/report` uses `admin.report` function to notify admin. It uses `x-forwarded-for` ip in the function. As we don't know how function is using it, for now I will assume it's for logging purposes.  
In the end it returns response in json format. (*cool*)  






**Setting initial nickname**
```
// Set name
let color = ['brown', 'black', 'yellow', 'white', 'grey', 'red'][Math.floor(Math.random()*6)];
let breed = ['ragamuffin', 'persian', 'siamese', 'siberian', 'birman', 'bombay', 'ragdoll'][Math.floor(Math.random()*7)];
if (!localStorage.name) localStorage.name = color + '_' + breed;
```
Here we can see how we are assigned our nicknames when we first enter in the chat room. Nothing fancy, code just selects random elements from array of colors and breeds and put them in `color` and `breed` variables respectively.

Lets execute both in our chat room to see how they work.  
Execution of `/secret 1g0ts3cr3t5` results in  

![secret execution](../ctfs/gctf18/web/cat_chat-210/secret_execution.png)  

Okay, so it changes the secret
